use strict;
use Test::More;
use Test::Deep ();

use lib 't';

use_ok 'Support::TestSetup';
use SL::DATEV qw(:CONSTANTS);
use DateTime;

Support::TestSetup::login();

# first, test all the accessors
my $d = new_ok('SL::DATEV' => [], 'new without params');

# export_type
ok(!$d->has_exporttype, 'no exporttype');
is($d->exporttype(DATEV_ET_BUCHUNGEN), DATEV_ET_BUCHUNGEN, 'set exporttype');
is($d->exporttype, DATEV_ET_BUCHUNGEN, 'get exporttype');
ok($d->has_exporttype, 'now exporttype');

# export_path/download_token
ok(!$d->has_format, 'no format');
is($d->format(DATEV_FORMAT_KNE), DATEV_FORMAT_KNE, 'set format');
is($d->format, DATEV_FORMAT_KNE, 'get format');
ok($d->has_format, 'now format');

# check if autogenerated download token work work
ok($d->export_path, 'auto generated export path');
ok($d->download_token, 'auto generated download token');

my $export_path = $d->export_path;
my $download_token = $d->download_token;

# see if that's roundtrip safe
$d = new_ok('SL::DATEV' => [ download_token => $download_token ], 'new with dl token');

is($d->download_token, $download_token, 'previously set download token');
is($d->export_path, $export_path, 'export path from download token');


# array attributes
Test::Deep::cmp_deeply([$d->filenames], [], 'init filenames');
is($d->add_filenames(qw(a b c)), 3, 'add filenames');
Test::Deep::cmp_deeply([$d->filenames], [qw(a b c)], 'get filenames');

Test::Deep::cmp_deeply([$d->errors], [], 'init errors');
is($d->add_error(qw(a b c)), 3, 'add error');
Test::Deep::cmp_deeply([$d->errors], [qw(a b c)], 'get errors');

Test::Deep::cmp_deeply([$d->net_gross_differences], [], 'init net_gross_differences');
is($d->add_net_gross_differences(qw(1 2 3)), 3, 'add net_gross_differences');
Test::Deep::cmp_deeply([$d->net_gross_differences], [qw(1 2 3)], 'get net_gross_differences');
is($d->sum_net_gross_differences, 6, 'sum net_gross_differences');


#get/set attributes

is($d->from, undef, 'init from');
is($d->from(DateTime->today), DateTime->today, 'set from');
is($d->from, DateTime->today, 'get from');

is($d->to, undef, 'init to');
is($d->to(DateTime->today), DateTime->today, 'set to');
is($d->to, DateTime->today, 'get to');

is($d->accnofrom, undef, 'init accnofrom');
is($d->accnofrom('3400'), '3400', 'set accnofrom');
is($d->accnofrom, '3400', 'get accnofrom');

is($d->accnoto, undef, 'init accnoto');
is($d->accnoto('3400'), '3400', 'set accnoto');
is($d->accnoto, '3400', 'get accnoto');

# dbh handling
is($d->dbh, $::form->get_standard_dbh, 'init dbh');
ok(!$d->provided_dbh, 'no dbh provided');

my $other_dbh = $::form->get_standard_dbh->clone;

$d = new_ok('SL::DATEV' => [ dbh => $other_dbh ], 'new with dbh');
isnt($d->dbh, $::form->get_standard_dbh, 'now a different dbh');
ok($d->provided_dbh, 'now got some provided dbh');


$d = new_ok('SL::DATEV' => [], 'another clean one');
is($d->fromto, undef, 'if no from or to -> fromto undef');

# TODO:error handling. test that stuff dies if it has to

done_testing();


1;
